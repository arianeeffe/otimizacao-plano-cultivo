# -*- coding: utf-8 -*-
"""Projeto_final_ga

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/146lZRrlknwmrDqIIjqystisdfS_4W9KL

# **Atividade Prática - Otimização do Plano de Cultivo de uma Multinacional**
Notebook com implementação do Algoritmo Genético para otimização do plano de cultivo.

**Objetivo:** Maximizar o lucro de um plano de cultivo selecionando as melhores opções de plantio (Produto/Estado) dentro de um limite de terra disponível.

**Restrições:**


*   Área Máxima de 15000 hectares
*   Mínimo 10 bananas em estados diferentes.
*   Mínimo 5 laranjas em estados diferentes.
*   Mínimo 5 Maracujá em estados diferentes
"""

import time
import numpy as np
import pandas as pd
import random
import matplotlib.pyplot as plt

PATH = "https://raw.githubusercontent.com/lid-ufpa/genial/refs/heads/main/projeto-final/ga/pam.csv"  # ajuste se quiser usar arquivo local

dados = pd.read_csv(PATH)
dados

"""# Individuo (Cromossomo)
Aqui definimos a representação do indivíduo e a estratégia de inicialização da população. Utilizamos uma inicialização ponderada (pesos) para aumentar a viabilidade das soluções iniciais. Atribuímos 95% de probabilidade ao gene "0" (não plantado) e apenas 5% ao gene "1" (plantado). Essa estratégia evita que os indivíduos da primeira geração violem excessivamente a restrição de área máxima.
"""

pesos_iniciais = [0.95, 0.05]
limite_area = 15000
num_genes = 226

"""# População
Nesta etapa, geramos a população inicial de forma aleatória. Criamos uma matriz contendo 0s e 1s, respeitando as probabilidades definidas anteriormente.
"""

tamanho_populacao = 100

matriz_genes_inicial = np.random.choice([0, 1], size=(tamanho_populacao, num_genes), p=pesos_iniciais)

df_populacao = pd.DataFrame(matriz_genes_inicial)
df_populacao.head()

"""## Função de aptidão (*fitness*)

Esta função é responsável por atribuir uma nota de qualidade a cada plano de cultivo. A lógica baseia-se em maximizar o lucro, mas com um sistema rigoroso de penalidade para garantir a viabiliadede do projeto.
Primeiro, soma-se o lucro de todas as culturas selecionadas, depois, o algoritmo checa se o plano viola alguma restrição. Por fim, caso alguma regra seja quebrada, aplica-se uma multa ao lucro, reduzindo drasticamente o fitness daquele indivíduo e suas chances de reprodução, garantindo que a evolução priorize soluções válidas.
"""

def avaliar_individuo(linha_genes):
    indices_escolhidos = linha_genes[linha_genes == 1].index
    cultivos = dados.loc[indices_escolhidos]

    area_total = cultivos['Área destinada à colheita'].sum()
    lucro_total = cultivos['Lucro'].sum()

    penalidade = 0

    if area_total > limite_area:
        penalidade += (area_total - limite_area) * 1000000

    contagem = cultivos.groupby('Produto')['Estados'].nunique()

    n_banana = contagem.get('Banana', 0)
    n_laranja = contagem.get('Laranja', 0)
    n_maracuja = contagem.get('Maracujá', 0)

    if n_banana < 10: penalidade += (10 - n_banana) * 1000000
    if n_laranja < 5: penalidade += (5 - n_laranja) * 1000000
    if n_maracuja < 5: penalidade += (5 - n_maracuja) * 1000000

    fitness = lucro_total - penalidade

    return pd.Series({
        'Lucro': lucro_total,
        'Área': area_total,
        'Banana_Estados': n_banana,
        'Laranja_Estados': n_laranja,
        'Maracuja_Estados': n_maracuja,
        'Fitness': fitness
    })

"""## Geração
Nesta etapa em que a simulação ocorre. O processo é repetido iterativamente por um número definido de gerações (`n_geracoes`). A cada geração, o algoritmo calcula a aptidão de todos os planos de cultivo da população atual e identifica e armazena a melhor solução global encontrada até o momento.
"""

n_geracoes = 100
historico_fitness = []
melhor_solucao_global = None

for geracao in range(n_geracoes):
    resultados = df_populacao.apply(avaliar_individuo, axis=1)
    df_completo = pd.concat([df_populacao, resultados], axis=1)
    df_completo = df_completo.sort_values(by='Fitness', ascending=False)

    melhor_fitness_atual = df_completo.iloc[0]['Fitness']
    historico_fitness.append(melhor_fitness_atual)

    if melhor_solucao_global is None or melhor_fitness_atual > melhor_solucao_global['Fitness']:
        melhor_solucao_global = df_completo.iloc[0].copy()

    if geracao % 5 == 0:
        print(f"Geração {geracao}: Melhor Lucro = R$ {melhor_fitness_atual:,.2f}")

"""## Seleção dos pais
Antes de iniciarmos os cruzamentos, aplicamos a técnica de Elitismo. O objetivo é proteger a qualidade genética da população. Selecionamos os 20% melhores indivíduos (aqueles com maior lucro) e os copiamos integralmente para a próxima geração. Isso garante que as melhores soluções encontradas até agora não sejam perdidas ou "estragadas" pelos processos aleatórios de cruzamento e mutação.
"""

qtd_elite = int(tamanho_populacao * 0.2)
elite_genes = df_completo.iloc[:qtd_elite, :num_genes].values

nova_geracao = list(elite_genes)

"""## Cruzamento (*Crossover*)
Nesta etapa, ocorre a reprodução. O objetivo é criar novos indivíduos misturando as características de soluções que já são boas.
Para garantir a qualidade dos descendentes, limitamos a escolha dos pais à metade superior da população (os 50% melhores). Isso aumenta a chance de propagar "genes de lucro alto" . Além disso, utilizamos o método de Ponto de Corte Único. Escolhemos um ponto aleatório no vetor de genes; o filho herda a primeira parte do Pai 1 e a segunda parte do Pai 2. Isso permite combinar, por exemplo, a estratégia de Bananas de um plano com a estratégia de Laranjas de outro.
"""

def crossover(pai1, pai2):
    ponto_corte = random.randint(1, len(pai1) - 1)
    return np.concatenate([pai1[:ponto_corte], pai2[ponto_corte:]])

pais_potenciais = df_completo.iloc[:int(tamanho_populacao/2)]

idx_pai1 = random.randint(0, len(pais_potenciais)-1)
idx_pai2 = random.randint(0, len(pais_potenciais)-1)

pai1 = pais_potenciais.iloc[idx_pai1, :num_genes].values
pai2 = pais_potenciais.iloc[idx_pai2, :num_genes].values

filho = crossover(pai1, pai2)

"""## Mutação
Após o cruzamento, aplicamos o operador de Mutação. Esta etapa é fundamental para introduzir variabilidade genética na população e impedir que o algoritmo convirja prematuramente para uma solução que parece boa, mas não é a melhor possível (máximo local). Percorremos cada gene do novo indivíduo e, com uma pequena probabilidade, invertemos seu valor (se era 0 vira 1, se era 1 vira 0). Isso simula o surgimento de novas opções de cultivo que não existiam nos pais.
"""

def mutacao(individuo, taxa=0.01):
    for i in range(len(individuo)):
        if random.random() < taxa:
            individuo[i] = 1 - individuo[i]
    return individuo

TAXA_MUTACAO = 0.05

filho = mutacao(filho, TAXA_MUTACAO)
nova_geracao.append(filho)

"""## Execução"""

n_geracoes = 100
tamanho_populacao = 100
taxa_mutacao = 0.01
historico_fitness = []
melhor_solucao_global = None

for geracao in range(n_geracoes):

    # 1. AVALIAÇÃO
    # Aplica a função de fitness em toda a população atual
    resultados = df_populacao.apply(avaliar_individuo, axis=1)

    # Junta os genes com os resultados
    df_completo = pd.concat([df_populacao, resultados], axis=1)

    # Ordena do maior fitness para o menor (Melhores no topo)
    df_completo = df_completo.sort_values(by='Fitness', ascending=False)

    # --- MONITORAMENTO ---
    melhor_fitness_atual = df_completo.iloc[0]['Fitness']
    historico_fitness.append(melhor_fitness_atual)

    # Salva a melhor solução global se encontrarmos um recorde
    if melhor_solucao_global is None or melhor_fitness_atual > melhor_solucao_global['Fitness']:
        melhor_solucao_global = df_completo.iloc[0].copy()

    # Exibe progresso a cada 5 gerações
    if geracao % 5 == 0:
        print(f"Geração {geracao}: Melhor Lucro Ajustado = R$ {melhor_fitness_atual:,.2f}")

    # 2. SELEÇÃO (ELITISMO)
    # Selecionamos os Top 20% para passarem direto para a próxima geração
    qtd_elite = int(tamanho_populacao * 0.2)
    elite_genes = df_completo.iloc[:qtd_elite, :num_genes].values

    # A nova geração começa com a elite
    nova_geracao = list(elite_genes)

    # 3. REPRODUÇÃO (Preencher o resto da população)
    # Enquanto a nova geração não estiver cheia...
    while len(nova_geracao) < tamanho_populacao:

        # Seleção de Pais: Escolhemos aleatoriamente dentre a metade superior (os melhores)
        pais_potenciais = df_completo.iloc[:int(tamanho_populacao/2)]

        idx_pai1 = random.randint(0, len(pais_potenciais)-1)
        idx_pai2 = random.randint(0, len(pais_potenciais)-1)

        pai1 = pais_potenciais.iloc[idx_pai1, :num_genes].values
        pai2 = pais_potenciais.iloc[idx_pai2, :num_genes].values

        # Cruzamento
        filho = crossover(pai1, pai2)

        # Mutação
        filho = mutacao(filho, taxa_mutacao)

        # Adiciona o filho na nova geração
        nova_geracao.append(filho)

    # 4. ATUALIZAÇÃO
    # Substitui a população antiga pela nova
    df_populacao = pd.DataFrame(nova_geracao)

"""## Resultado Final"""

# Gráfico de Evolução
plt.figure(figsize=(10,5))
plt.plot(historico_fitness, color='green')
plt.title("Evolução do Lucro (Fitness)")
plt.xlabel("Geração")
plt.ylabel("Lucro (R$)")
plt.grid(True, alpha=0.3)
plt.show()

# Exibir os detalhes do Vencedor
print(f"Lucro: R$ {melhor_solucao_global['Lucro']:,.2f}")
print(f"Área Usada: {melhor_solucao_global['Área']:.2f} ha (Limite: 15.000)")
print("-" * 30)
print(f"Estados com Banana: {melhor_solucao_global['Banana_Estados']} (Meta: 10)")
print(f"Estados com Laranja: {melhor_solucao_global['Laranja_Estados']} (Meta: 5)")
print(f"Estados com Maracujá: {melhor_solucao_global['Maracuja_Estados']} (Meta: 5)")

genes_vencedores = melhor_solucao_global.iloc[:num_genes].values.astype(bool)
plano_final = dados[genes_vencedores].copy()
resumo_mapa = pd.crosstab(plano_final['Estados'], plano_final['Produto'])
# Adiciona uma coluna de totais para facilitar a leitura
resumo_mapa['TOTAL'] = resumo_mapa.sum(axis=1)
resumo_mapa = resumo_mapa.sort_values(by='TOTAL', ascending=False)
resumo_mapa
